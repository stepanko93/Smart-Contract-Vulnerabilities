# STBL Protocol: Mathematical Insolvency via Missing Decimal Normalization

## üìù Overview
This repository details a critical mathematical vulnerability discovered in the STBL Protocol's core logic (`STBL_Core.put()`). The vulnerability arises from a failure to normalize token decimals when calculating reward distributions, specifically impacting 6-decimal assets like USDC and USDT.

## üî¨ Vulnerability Details
In DeFi protocols, maintaining internal accounting parity is critical when interacting with tokens of varying decimal precisions (e.g., 18 decimals for WETH/DAI vs. 6 decimals for USDC/USDT).

1. **The Flaw:** The `STBL_Core.put()` function accepts user deposits but fails to scale up 6-decimal inputs to the protocol's standard 18-decimal internal accounting precision.
2. **Mathematical Imbalance:** When a user deposits USDC, the raw `amount` is recorded directly into the protocol's state. Because `1 USDC` is represented as `1,000,000` (6 zeros) instead of `1,000,000,000,000,000,000` (18 zeros), the internal calculations for share minting and reward distribution become severely skewed.
3. **Exploitation:** An attacker can exploit this discrepancy to manipulate the pool's weightings. Depending on the exact reward formula, this missing normalization either allows the attacker to drain rewards at a massively inflated rate relative to their actual USD value deposited, or it bricks the withdrawal logic due to underflow errors when mixing 6-decimal and 18-decimal balances.

## üí• Impact
* **Category:** Stealing or loss of funds / Mathematical Insolvency.
* **Severity:** CRITICAL
* The lack of decimal normalization fundamentally breaks the core economic model of the protocol. It allows malicious actors to exploit USDC/USDT deposits to steal yield from users staking standard 18-decimal assets, ultimately leading to protocol insolvency.

## üõ°Ô∏è Mitigation
All incoming token amounts must be normalized to a standard precision (e.g., 18 decimals) before any state updates or share calculations occur. 
Example fix:
```solidity
uint256 normalizedAmount = amount;
uint8 decimals = IERC20Metadata(token).decimals();
if (decimals < 18) {
    normalizedAmount = amount * (10 ** (18 - decimals));
}
